===== FILE: .gitignore =====
/target
**/*.rs.bk
**/*.log
.vscode
.idea
.DS_Store

===== FILE: Cargo.lock =====
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 4

[[package]]
name = "ab_glyph"
version = "0.2.32"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "01c0457472c38ea5bd1c3b5ada5e368271cb550be7a4ca4a0b4634e9913f6cc2"
dependencies = [
 "ab_glyph_rasterizer",
 "owned_ttf_parser",
]

[[package]]
name = "ab_glyph_rasterizer"
version = "0.1.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "366ffbaa4442f4684d91e2cd7c5ea7c4ed8add41959a31447066e279e432b618"

[[package]]
name = "addr2line"
version = "0.25.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1b5d307320b3181d6d7954e663bd7c774a838b8220fe0593c86d9fb09f498b4b"
dependencies = [
 "gimli",
]

[[package]]
name = "adler2"
version = "2.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "320119579fcad9c21884f5c4861d16174d0e06250625266f50fe6898340abefa"

[[package]]
name = "ahash"
version = "0.8.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5a15f179cd60c4584b8a8c596927aadc462e27f2ca70c04e0071964a73ba7a75"
dependencies = [
 "cfg-if",
 "once_cell",
 "version_check",
 "zerocopy",
]

[[package]]
name = "allocator-api2"
version = "0.2.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "683d7910e743518b0e34f1186f92494becacb047c7b6bf616c96772180fef923"

[[package]]
name = "android-activity"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "64529721f27c2314ced0890ce45e469574a73e5e6fdd6e9da1860eb29285f5e0"
dependencies = [
 "android-properties",
 "bitflags 1.3.2",
 "cc",
 "jni-sys",
 "libc",
 "log",
 "ndk",
 "ndk-context",
 "ndk-sys",
 "num_enum 0.6.1",
]

[[package]]
name = "android-properties"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fc7eb209b1518d6bb87b283c20095f5228ecda460da70b44f0802523dea6da04"

[[package]]
name = "android_system_properties"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
dependencies = [
 "libc",
]

[[package]]
name = "arrayref"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "76a2e8124351fda1ef8aaaa3bbd7ebbcb486bbcd4225aca0aa0d84bb2db8fecb"

[[package]]
name = "arrayvec"
version = "0.7.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7c02d123df017efcdfbd739ef81735b36c5ba83ec3c59c80a9d7ecc718f92e50"

[[package]]
name = "ash"
version = "0.37.3+1.3.251"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "39e9c3835d686b0a6084ab4234fcd1b07dbf6e4767dce60874b12356a25ecd4a"
dependencies = [
 "libloading 0.7.4",
]

[[package]]
name = "autocfg"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c08606f8c3cbf4ce6ec8e28fb0014a2c086708fe954eaa885384a6165172e7e8"

[[package]]
name = "backtrace"
version = "0.3.76"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bb531853791a215d7c62a30daf0dde835f381ab5de4589cfe7c649d2cbe92bd6"
dependencies = [
 "addr2line",
 "cfg-if",
 "libc",
 "miniz_oxide",
 "object",
 "rustc-demangle",
 "windows-link",
]

[[package]]
name = "bit-set"
version = "0.5.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0700ddab506f33b20a03b13996eccd309a48e5ff77d0d95926aa0210fb4e95f1"
dependencies = [
 "bit-vec",
]

[[package]]
name = "bit-vec"
version = "0.6.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "349f9b6a179ed607305526ca489b34ad0a41aed5f7980fa90eb03160b69598fb"

[[package]]
name = "bitflags"
version = "1.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"

[[package]]
name = "bitflags"
version = "2.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "812e12b5285cc515a9c72a5c1d3b6d46a19dac5acfef5265968c166106e31dd3"

[[package]]
name = "block"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0d8c1fef690941d3e7788d328517591fecc684c084084702d6ff1641e993699a"

[[package]]
name = "block-sys"
version = "0.1.0-beta.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fa55741ee90902547802152aaf3f8e5248aab7e21468089560d4c8840561146"
dependencies = [
 "objc-sys",
]

[[package]]
name = "block2"
version = "0.2.0-alpha.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8dd9e63c1744f755c2f60332b88de39d341e5e86239014ad839bd71c106dec42"
dependencies = [
 "block-sys",
 "objc2-encode",
]

[[package]]
name = "bumpalo"
version = "3.19.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5dd9dc738b7a8311c7ade152424974d8115f2cdad61e8dab8dac9f2362298510"

[[package]]
name = "bytemuck"
version = "1.24.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fbdf580320f38b612e485521afda1ee26d10cc9884efaaa750d383e13e3c5f4"
dependencies = [
 "bytemuck_derive",
]

[[package]]
name = "bytemuck_derive"
version = "1.10.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f9abbd1bc6865053c427f7198e6af43bfdedc55ab791faed4fbd361d789575ff"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.113",
]

[[package]]
name = "calloop"
version = "0.10.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "52e0d00eb1ea24371a97d2da6201c6747a633dc6dc1988ef503403b4c59504a8"
dependencies = [
 "bitflags 1.3.2",
 "log",
 "nix 0.25.1",
 "slotmap",
 "thiserror",
 "vec_map",
]

[[package]]
name = "cc"
version = "1.2.51"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7a0aeaff4ff1a90589618835a598e545176939b97874f7abc7851caa0618f203"
dependencies = [
 "find-msvc-tools",
 "jobserver",
 "libc",
 "shlex",
]

[[package]]
name = "cfg-if"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9330f8b2ff13f34540b44e946ef35111825727b38d33286ef986142615121801"

[[package]]
name = "cfg_aliases"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fd16c4719339c4530435d38e511904438d07cce7950afa3718a84ac36c10e89e"

[[package]]
name = "client"
version = "0.1.0"
dependencies = [
 "glam",
 "pollster",
 "render",
 "winit",
]

[[package]]
name = "codespan-reporting"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3538270d33cc669650c4b093848450d380def10c331d38c768e34cac80576e6e"
dependencies = [
 "termcolor",
 "unicode-width",
]

[[package]]
name = "com-rs"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bf43edc576402991846b093a7ca18a3477e0ef9c588cde84964b5d3e43016642"

[[package]]
name = "core"
version = "0.1.0"

[[package]]
name = "core-foundation"
version = "0.9.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "91e195e091a93c46f7102ec7818a2aa394e1e1771c3ab4825963fa03e45afb8f"
dependencies = [
 "core-foundation-sys",
 "libc",
]

[[package]]
name = "core-foundation-sys"
version = "0.8.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"

[[package]]
name = "core-graphics"
version = "0.22.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2581bbab3b8ffc6fcbd550bf46c355135d16e9ff2a6ea032ad6b9bf1d7efe4fb"
dependencies = [
 "bitflags 1.3.2",
 "core-foundation",
 "core-graphics-types",
 "foreign-types",
 "libc",
]

[[package]]
name = "core-graphics-types"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "45390e6114f68f718cc7a830514a96f903cccd70d02a8f6d9f643ac4ba45afaf"
dependencies = [
 "bitflags 1.3.2",
 "core-foundation",
 "libc",
]

[[package]]
name = "crc32fast"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9481c1c90cbf2ac953f07c8d4a58aa3945c425b7185c9154d67a65e4230da511"
dependencies = [
 "cfg-if",
]

[[package]]
name = "d3d12"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d8f0de2f5a8e7bd4a9eec0e3c781992a4ce1724f68aec7d7a3715344de8b39da"
dependencies = [
 "bitflags 1.3.2",
 "libloading 0.7.4",
 "winapi",
]

[[package]]
name = "dispatch"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bd0c93bb4b0c6d9b77f4435b0ae98c24d17f1c45b2ff844c6151a07256ca923b"

[[package]]
name = "dlib"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "330c60081dcc4c72131f8eb70510f1ac07223e5d4163db481a04a0befcffa412"
dependencies = [
 "libloading 0.8.9",
]

[[package]]
name = "downcast-rs"
version = "1.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "75b325c5dbd37f80359721ad39aca5a29fb04c89279657cffdda8736d0c0b9d2"

[[package]]
name = "equivalent"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "877a4ace8713b0bcf2a4e7eec82529c029f1d0619886d18145fea96c3ffe5c0f"

[[package]]
name = "fdeflate"
version = "0.3.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e6853b52649d4ac5c0bd02320cddc5ba956bdb407c4b75a2c6b75bf51500f8c"
dependencies = [
 "simd-adler32",
]

[[package]]
name = "find-msvc-tools"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "645cbb3a84e60b7531617d5ae4e57f7e27308f6445f5abf653209ea76dec8dff"

[[package]]
name = "flate2"
version = "1.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bfe33edd8e85a12a67454e37f8c75e730830d83e313556ab9ebf9ee7fbeb3bfb"
dependencies = [
 "crc32fast",
 "miniz_oxide",
]

[[package]]
name = "foreign-types"
version = "0.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f6f339eb8adc052cd2ca78910fda869aefa38d22d5cb648e6485e4d3fc06f3b1"
dependencies = [
 "foreign-types-shared",
]

[[package]]
name = "foreign-types-shared"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "00b0228411908ca8685dba7fc2cdd70ec9990a6e753e89b6ac91a84c40fbaf4b"

[[package]]
name = "getrandom"
version = "0.3.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "899def5c37c4fd7b2664648c28120ecec138e4d395b459e5ca34f9cce2dd77fd"
dependencies = [
 "cfg-if",
 "libc",
 "r-efi",
 "wasip2",
]

[[package]]
name = "gimli"
version = "0.32.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e629b9b98ef3dd8afe6ca2bd0f89306cec16d43d907889945bc5d6687f2f13c7"

[[package]]
name = "glam"
version = "0.25.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "151665d9be52f9bb40fc7966565d39666f2d1e69233571b71b87791c7e0528b3"

[[package]]
name = "glow"
version = "0.12.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ca0fe580e4b60a8ab24a868bc08e2f03cbcb20d3d676601fa909386713333728"
dependencies = [
 "js-sys",
 "slotmap",
 "wasm-bindgen",
 "web-sys",
]

[[package]]
name = "gpu-alloc"
version = "0.5.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "22beaafc29b38204457ea030f6fb7a84c9e4dd1b86e311ba0542533453d87f62"
dependencies = [
 "bitflags 1.3.2",
 "gpu-alloc-types",
]

[[package]]
name = "gpu-alloc-types"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "54804d0d6bc9d7f26db4eaec1ad10def69b599315f487d32c334a80d1efe67a5"
dependencies = [
 "bitflags 1.3.2",
]

[[package]]
name = "gpu-allocator"
version = "0.22.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ce95f9e2e11c2c6fadfce42b5af60005db06576f231f5c92550fdded43c423e8"
dependencies = [
 "backtrace",
 "log",
 "thiserror",
 "winapi",
 "windows",
]

[[package]]
name = "gpu-descriptor"
version = "0.2.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cc11df1ace8e7e564511f53af41f3e42ddc95b56fd07b3f4445d2a6048bc682c"
dependencies = [
 "bitflags 2.10.0",
 "gpu-descriptor-types",
 "hashbrown 0.14.5",
]

[[package]]
name = "gpu-descriptor-types"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6bf0b36e6f090b7e1d8a4b49c0cb81c1f8376f72198c65dd3ad9ff3556b8b78c"
dependencies = [
 "bitflags 2.10.0",
]

[[package]]
name = "hashbrown"
version = "0.12.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8a9ee70c43aaf417c914396645a0fa852624801b24ebb7ae78fe8272889ac888"

[[package]]
name = "hashbrown"
version = "0.14.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e5274423e17b7c9fc20b6e7e208532f9b19825d82dfd615708b70edd83df41f1"
dependencies = [
 "ahash",
 "allocator-api2",
]

[[package]]
name = "hashbrown"
version = "0.16.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "841d1cc9bed7f9236f321df977030373f4a4163ae1a7dbfe1a51a2c1a51d9100"

[[package]]
name = "hassle-rs"
version = "0.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1397650ee315e8891a0df210707f0fc61771b0cc518c3023896064c5407cb3b0"
dependencies = [
 "bitflags 1.3.2",
 "com-rs",
 "libc",
 "libloading 0.7.4",
 "thiserror",
 "widestring",
 "winapi",
]

[[package]]
name = "hexf-parse"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dfa686283ad6dd069f105e5ab091b04c62850d3e4cf5d67debad1933f55023df"

[[package]]
name = "indexmap"
version = "1.9.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bd070e393353796e801d209ad339e89596eb4c8d430d18ede6a1cced8fafbd99"
dependencies = [
 "autocfg",
 "hashbrown 0.12.3",
]

[[package]]
name = "indexmap"
version = "2.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0ad4bb2b565bca0645f4d68c5c9af97fba094e9791da685bf83cb5f3ce74acf2"
dependencies = [
 "equivalent",
 "hashbrown 0.16.1",
]

[[package]]
name = "instant"
version = "0.1.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e0242819d153cba4b4b05a5a8f2a7e9bbf97b6055b2a002b395c96b5ff3c0222"
dependencies = [
 "cfg-if",
 "js-sys",
 "wasm-bindgen",
 "web-sys",
]

[[package]]
name = "jni-sys"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8eaf4bc02d17cbdd7ff4c7438cafcdf7fb9a4613313ad11b4f8fefe7d3fa0130"

[[package]]
name = "jobserver"
version = "0.1.34"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9afb3de4395d6b3e67a780b6de64b51c978ecf11cb9a462c66be7d4ca9039d33"
dependencies = [
 "getrandom",
 "libc",
]

[[package]]
name = "js-sys"
version = "0.3.83"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "464a3709c7f55f1f721e5389aa6ea4e3bc6aba669353300af094b29ffbdde1d8"
dependencies = [
 "once_cell",
 "wasm-bindgen",
]

[[package]]
name = "khronos-egl"
version = "4.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8c2352bd1d0bceb871cb9d40f24360c8133c11d7486b68b5381c1dd1a32015e3"
dependencies = [
 "libc",
 "libloading 0.7.4",
 "pkg-config",
]

[[package]]
name = "lazy_static"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"

[[package]]
name = "libc"
version = "0.2.179"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c5a2d376baa530d1238d133232d15e239abad80d05838b4b59354e5268af431f"

[[package]]
name = "libloading"
version = "0.7.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b67380fd3b2fbe7527a606e18729d21c6f3951633d0500574c4dc22d2d638b9f"
dependencies = [
 "cfg-if",
 "winapi",
]

[[package]]
name = "libloading"
version = "0.8.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d7c4b02199fee7c5d21a5ae7d8cfa79a6ef5bb2fc834d6e9058e89c825efdc55"
dependencies = [
 "cfg-if",
 "windows-link",
]

[[package]]
name = "libredox"
version = "0.1.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3d0b95e02c851351f877147b7deea7b1afb1df71b63aa5f8270716e0c5720616"
dependencies = [
 "bitflags 2.10.0",
 "libc",
 "redox_syscall 0.7.0",
]

[[package]]
name = "lock_api"
version = "0.4.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "224399e74b87b5f3557511d98dff8b14089b3dadafcab6bb93eab67d3aace965"
dependencies = [
 "scopeguard",
]

[[package]]
name = "log"
version = "0.4.29"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e5032e24019045c762d3c0f28f5b6b8bbf38563a65908389bf7978758920897"

[[package]]
name = "malloc_buf"
version = "0.0.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "62bb907fe88d54d8d9ce32a3cceab4218ed2f6b7d35617cafe9adf84e43919cb"
dependencies = [
 "libc",
]

[[package]]
name = "memchr"
version = "2.7.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f52b00d39961fc5b2736ea853c9cc86238e165017a493d1d5c8eac6bdc4cc273"

[[package]]
name = "memmap2"
version = "0.5.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "83faa42c0a078c393f6b29d5db232d8be22776a891f8f56e5284faee4a20b327"
dependencies = [
 "libc",
]

[[package]]
name = "memoffset"
version = "0.6.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5aa361d4faea93603064a027415f07bd8e1d5c88c9fbf68bf56a285428fd79ce"
dependencies = [
 "autocfg",
]

[[package]]
name = "metal"
version = "0.24.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "de11355d1f6781482d027a3b4d4de7825dcedb197bf573e0596d00008402d060"
dependencies = [
 "bitflags 1.3.2",
 "block",
 "core-graphics-types",
 "foreign-types",
 "log",
 "objc",
]

[[package]]
name = "miniz_oxide"
version = "0.8.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fa76a2c86f704bdb222d66965fb3d63269ce38518b83cb0575fca855ebb6316"
dependencies = [
 "adler2",
 "simd-adler32",
]

[[package]]
name = "mio"
version = "0.8.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a4a650543ca06a924e8b371db273b2756685faae30f8487da1b56505a8f78b0c"
dependencies = [
 "libc",
 "log",
 "wasi",
 "windows-sys 0.48.0",
]

[[package]]
name = "naga"
version = "0.12.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbcc2e0513220fd2b598e6068608d4462db20322c0e77e47f6f488dfcfc279cb"
dependencies = [
 "bit-set",
 "bitflags 1.3.2",
 "codespan-reporting",
 "hexf-parse",
 "indexmap 1.9.3",
 "log",
 "num-traits",
 "rustc-hash",
 "spirv",
 "termcolor",
 "thiserror",
 "unicode-xid",
]

[[package]]
name = "ndk"
version = "0.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "451422b7e4718271c8b5b3aadf5adedba43dc76312454b387e98fae0fc951aa0"
dependencies = [
 "bitflags 1.3.2",
 "jni-sys",
 "ndk-sys",
 "num_enum 0.5.11",
 "raw-window-handle",
 "thiserror",
]

[[package]]
name = "ndk-context"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "27b02d87554356db9e9a873add8782d4ea6e3e58ea071a9adb9a2e8ddb884a8b"

[[package]]
name = "ndk-sys"
version = "0.4.1+23.1.7779620"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3cf2aae958bd232cac5069850591667ad422d263686d75b52a065f9badeee5a3"
dependencies = [
 "jni-sys",
]

[[package]]
name = "net"
version = "0.1.0"
dependencies = [
 "core",
]

[[package]]
name = "nix"
version = "0.24.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fa52e972a9a719cecb6864fb88568781eb706bac2cd1d4f04a648542dbf78069"
dependencies = [
 "bitflags 1.3.2",
 "cfg-if",
 "libc",
 "memoffset",
]

[[package]]
name = "nix"
version = "0.25.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f346ff70e7dbfd675fe90590b92d59ef2de15a8779ae305ebcbfd3f0caf59be4"
dependencies = [
 "autocfg",
 "bitflags 1.3.2",
 "cfg-if",
 "libc",
 "memoffset",
]

[[package]]
name = "num-traits"
version = "0.2.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
dependencies = [
 "autocfg",
]

[[package]]
name = "num_enum"
version = "0.5.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1f646caf906c20226733ed5b1374287eb97e3c2a5c227ce668c1f2ce20ae57c9"
dependencies = [
 "num_enum_derive 0.5.11",
]

[[package]]
name = "num_enum"
version = "0.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7a015b430d3c108a207fd776d2e2196aaf8b1cf8cf93253e3a097ff3085076a1"
dependencies = [
 "num_enum_derive 0.6.1",
]

[[package]]
name = "num_enum_derive"
version = "0.5.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dcbff9bc912032c62bf65ef1d5aea88983b420f4f839db1e9b0c281a25c9c799"
dependencies = [
 "proc-macro-crate",
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "num_enum_derive"
version = "0.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "96667db765a921f7b295ffee8b60472b686a51d4f21c2ee4ffdb94c7013b65a6"
dependencies = [
 "proc-macro-crate",
 "proc-macro2",
 "quote",
 "syn 2.0.113",
]

[[package]]
name = "objc"
version = "0.2.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "915b1b472bc21c53464d6c8461c9d3af805ba1ef837e1cac254428f4a77177b1"
dependencies = [
 "malloc_buf",
 "objc_exception",
]

[[package]]
name = "objc-sys"
version = "0.2.0-beta.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "df3b9834c1e95694a05a828b59f55fa2afec6288359cda67146126b3f90a55d7"

[[package]]
name = "objc2"
version = "0.3.0-beta.3.patch-leaks.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7e01640f9f2cb1220bbe80325e179e532cb3379ebcd1bf2279d703c19fe3a468"
dependencies = [
 "block2",
 "objc-sys",
 "objc2-encode",
]

[[package]]
name = "objc2-encode"
version = "2.0.0-pre.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "abfcac41015b00a120608fdaa6938c44cb983fee294351cc4bac7638b4e50512"
dependencies = [
 "objc-sys",
]

[[package]]
name = "objc_exception"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ad970fb455818ad6cba4c122ad012fae53ae8b4795f86378bce65e4f6bab2ca4"
dependencies = [
 "cc",
]

[[package]]
name = "object"
version = "0.37.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ff76201f031d8863c38aa7f905eca4f53abbfa15f609db4277d44cd8938f33fe"
dependencies = [
 "memchr",
]

[[package]]
name = "once_cell"
version = "1.21.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"

[[package]]
name = "orbclient"
version = "0.3.50"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "52ad2c6bae700b7aa5d1cc30c59bdd3a1c180b09dbaea51e2ae2b8e1cf211fdd"
dependencies = [
 "libc",
 "libredox",
]

[[package]]
name = "owned_ttf_parser"
version = "0.25.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "36820e9051aca1014ddc75770aab4d68bc1e9e632f0f5627c4086bc216fb583b"
dependencies = [
 "ttf-parser",
]

[[package]]
name = "parking_lot"
version = "0.12.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "93857453250e3077bd71ff98b6a65ea6621a19bb0f559a85248955ac12c45a1a"
dependencies = [
 "lock_api",
 "parking_lot_core",
]

[[package]]
name = "parking_lot_core"
version = "0.9.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2621685985a2ebf1c516881c026032ac7deafcda1a2c9b7850dc81e3dfcb64c1"
dependencies = [
 "cfg-if",
 "libc",
 "redox_syscall 0.5.18",
 "smallvec",
 "windows-link",
]

[[package]]
name = "percent-encoding"
version = "2.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b4f627cb1b25917193a259e49bdad08f671f8d9708acfd5fe0a8c1455d87220"

[[package]]
name = "pkg-config"
version = "0.3.32"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7edddbd0b52d732b21ad9a5fab5c704c14cd949e5e9a1ec5929a24fded1b904c"

[[package]]
name = "platform"
version = "0.1.0"

[[package]]
name = "png"
version = "0.17.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "82151a2fc869e011c153adc57cf2789ccb8d9906ce52c0b39a6b5697749d7526"
dependencies = [
 "bitflags 1.3.2",
 "crc32fast",
 "fdeflate",
 "flate2",
 "miniz_oxide",
]

[[package]]
name = "pollster"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "22686f4785f02a4fcc856d3b3bb19bf6c8160d103f7a99cc258bddd0251dc7f2"

[[package]]
name = "proc-macro-crate"
version = "1.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f4c021e1093a56626774e81216a4ce732a735e5bad4868a03f3ed65ca0c3919"
dependencies = [
 "once_cell",
 "toml_edit",
]

[[package]]
name = "proc-macro2"
version = "1.0.105"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "535d180e0ecab6268a3e718bb9fd44db66bbbc256257165fc699dadf70d16fe7"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "profiling"
version = "1.0.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3eb8486b569e12e2c32ad3e204dbaba5e4b5b216e9367044f25f1dba42341773"

[[package]]
name = "quote"
version = "1.0.43"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dc74d9a594b72ae6656596548f56f667211f8a97b3d4c3d467150794690dc40a"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "r-efi"
version = "5.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "69cdb34c158ceb288df11e18b4bd39de994f6657d83847bdffdbd7f346754b0f"

[[package]]
name = "range-alloc"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c3d6831663a5098ea164f89cff59c6284e95f4e3c76ce9848d4529f5ccca9bde"

[[package]]
name = "raw-window-handle"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f2ff9a1f06a88b01621b7ae906ef0211290d1c8a168a15542486a8f61c0833b9"

[[package]]
name = "redox_syscall"
version = "0.3.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "567664f262709473930a4bf9e51bf2ebf3348f2e748ccc50dea20646858f8f29"
dependencies = [
 "bitflags 1.3.2",
]

[[package]]
name = "redox_syscall"
version = "0.5.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ed2bf2547551a7053d6fdfafda3f938979645c44812fbfcda098faae3f1a362d"
dependencies = [
 "bitflags 2.10.0",
]

[[package]]
name = "redox_syscall"
version = "0.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "49f3fe0889e69e2ae9e41f4d6c4c0181701d00e4697b356fb1f74173a5e0ee27"
dependencies = [
 "bitflags 2.10.0",
]

[[package]]
name = "render"
version = "0.1.0"
dependencies = [
 "bytemuck",
 "glam",
 "pollster",
 "wgpu",
 "winit",
]

[[package]]
name = "renderdoc-sys"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "19b30a45b0cd0bcca8037f3d0dc3421eaf95327a17cad11964fb8179b4fc4832"

[[package]]
name = "rustc-demangle"
version = "0.1.26"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56f7d92ca342cea22a06f2121d944b4fd82af56988c270852495420f961d4ace"

[[package]]
name = "rustc-hash"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "08d43f7aa6b08d49f382cde6a7982047c3426db949b1424bc4b7ec9ae12c6ce2"

[[package]]
name = "rustversion"
version = "1.0.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"

[[package]]
name = "scoped-tls"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e1cf6437eb19a8f4a6cc0f7dca544973b0b78843adbfeb3683d1a94a0024a294"

[[package]]
name = "scopeguard"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49"

[[package]]
name = "sctk-adwaita"
version = "0.5.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cda4e97be1fd174ccc2aae81c8b694e803fa99b34e8fd0f057a9d70698e3ed09"
dependencies = [
 "ab_glyph",
 "log",
 "memmap2",
 "smithay-client-toolkit",
 "tiny-skia",
]

[[package]]
name = "server"
version = "0.1.0"
dependencies = [
 "core",
 "net",
]

[[package]]
name = "shlex"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64"

[[package]]
name = "simd-adler32"
version = "0.3.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e320a6c5ad31d271ad523dcf3ad13e2767ad8b1cb8f047f75a8aeaf8da139da2"

[[package]]
name = "slotmap"
version = "1.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bdd58c3c93c3d278ca835519292445cb4b0d4dc59ccfdf7ceadaab3f8aeb4038"
dependencies = [
 "version_check",
]

[[package]]
name = "smallvec"
version = "1.15.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "67b1b7a3b5fe4f1376887184045fcf45c69e92af734b7aaddc05fb777b6fbd03"

[[package]]
name = "smithay-client-toolkit"
version = "0.16.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "870427e30b8f2cbe64bf43ec4b86e88fe39b0a84b3f15efd9c9c2d020bc86eb9"
dependencies = [
 "bitflags 1.3.2",
 "calloop",
 "dlib",
 "lazy_static",
 "log",
 "memmap2",
 "nix 0.24.3",
 "pkg-config",
 "wayland-client",
 "wayland-cursor",
 "wayland-protocols",
]

[[package]]
name = "spirv"
version = "0.2.0+1.5.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "246bfa38fe3db3f1dfc8ca5a2cdeb7348c78be2112740cc0ec8ef18b6d94f830"
dependencies = [
 "bitflags 1.3.2",
 "num-traits",
]

[[package]]
name = "static_assertions"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a2eb9349b6444b326872e140eb1cf5e7c522154d69e7a0ffb0fb81c06b37543f"

[[package]]
name = "strict-num"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6637bab7722d379c8b41ba849228d680cc12d0a45ba1fa2b48f2a30577a06731"

[[package]]
name = "syn"
version = "1.0.109"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72b64191b275b66ffe2469e8af2c1cfe3bafa67b529ead792a6d0160888b4237"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "syn"
version = "2.0.113"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "678faa00651c9eb72dd2020cbdf275d92eccb2400d568e419efdd64838145cb4"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "termcolor"
version = "1.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "06794f8f6c5c898b3275aebefa6b8a1cb24cd2c6c79397ab15774837a0bc5755"
dependencies = [
 "winapi-util",
]

[[package]]
name = "thiserror"
version = "1.0.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b6aaf5339b578ea85b50e080feb250a3e8ae8cfcdff9a461c9ec2904bc923f52"
dependencies = [
 "thiserror-impl",
]

[[package]]
name = "thiserror-impl"
version = "1.0.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4fee6c4efc90059e10f81e6d42c60a18f76588c3d74cb83a0b242a2b6c7504c1"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.113",
]

[[package]]
name = "tiny-skia"
version = "0.8.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "df8493a203431061e901613751931f047d1971337153f96d0e5e363d6dbf6a67"
dependencies = [
 "arrayref",
 "arrayvec",
 "bytemuck",
 "cfg-if",
 "png",
 "tiny-skia-path",
]

[[package]]
name = "tiny-skia-path"
version = "0.8.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "adbfb5d3f3dd57a0e11d12f4f13d4ebbbc1b5c15b7ab0a156d030b21da5f677c"
dependencies = [
 "arrayref",
 "bytemuck",
 "strict-num",
]

[[package]]
name = "toml_datetime"
version = "0.6.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "22cddaf88f4fbc13c51aebbf5f8eceb5c7c5a9da2ac40a13519eb5b0a0e8f11c"

[[package]]
name = "toml_edit"
version = "0.19.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1b5bb770da30e5cbfde35a2d7b9b8a2c4b8ef89548a7a6aeab5c9a576e3e7421"
dependencies = [
 "indexmap 2.12.1",
 "toml_datetime",
 "winnow",
]

[[package]]
name = "ttf-parser"
version = "0.25.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d2df906b07856748fa3f6e0ad0cbaa047052d4a7dd609e231c4f72cee8c36f31"

[[package]]
name = "unicode-ident"
version = "1.0.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9312f7c4f6ff9069b165498234ce8be658059c6728633667c526e27dc2cf1df5"

[[package]]
name = "unicode-width"
version = "0.1.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7dd6e30e90baa6f72411720665d41d89b9a3d039dc45b8faea1ddd07f617f6af"

[[package]]
name = "unicode-xid"
version = "0.2.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ebc1c04c71510c7f702b52b7c350734c9ff1295c464a03335b00bb84fc54f853"

[[package]]
name = "vec_map"
version = "0.8.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f1bddf1187be692e79c5ffeab891132dfb0f236ed36a43c7ed39f1165ee20191"

[[package]]
name = "version_check"
version = "0.9.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b928f33d975fc6ad9f86c8f283853ad26bdd5b10b7f1542aa2fa15e2289105a"

[[package]]
name = "wasi"
version = "0.11.1+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ccf3ec651a847eb01de73ccad15eb7d99f80485de043efb2f370cd654f4ea44b"

[[package]]
name = "wasip2"
version = "1.0.1+wasi-0.2.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0562428422c63773dad2c345a1882263bbf4d65cf3f42e90921f787ef5ad58e7"
dependencies = [
 "wit-bindgen",
]

[[package]]
name = "wasm-bindgen"
version = "0.2.106"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0d759f433fa64a2d763d1340820e46e111a7a5ab75f993d1852d70b03dbb80fd"
dependencies = [
 "cfg-if",
 "once_cell",
 "rustversion",
 "wasm-bindgen-macro",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-futures"
version = "0.4.45"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cc7ec4f8827a71586374db3e87abdb5a2bb3a15afed140221307c3ec06b1f63b"
dependencies = [
 "cfg-if",
 "js-sys",
 "wasm-bindgen",
 "web-sys",
]

[[package]]
name = "wasm-bindgen-macro"
version = "0.2.106"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "48cb0d2638f8baedbc542ed444afc0644a29166f1595371af4fecf8ce1e7eeb3"
dependencies = [
 "quote",
 "wasm-bindgen-macro-support",
]

[[package]]
name = "wasm-bindgen-macro-support"
version = "0.2.106"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cefb59d5cd5f92d9dcf80e4683949f15ca4b511f4ac0a6e14d4e1ac60c6ecd40"
dependencies = [
 "bumpalo",
 "proc-macro2",
 "quote",
 "syn 2.0.113",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-shared"
version = "0.2.106"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cbc538057e648b67f72a982e708d485b2efa771e1ac05fec311f9f63e5800db4"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "wayland-client"
version = "0.29.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3f3b068c05a039c9f755f881dc50f01732214f5685e379829759088967c46715"
dependencies = [
 "bitflags 1.3.2",
 "downcast-rs",
 "libc",
 "nix 0.24.3",
 "scoped-tls",
 "wayland-commons",
 "wayland-scanner",
 "wayland-sys",
]

[[package]]
name = "wayland-commons"
version = "0.29.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8691f134d584a33a6606d9d717b95c4fa20065605f798a3f350d78dced02a902"
dependencies = [
 "nix 0.24.3",
 "once_cell",
 "smallvec",
 "wayland-sys",
]

[[package]]
name = "wayland-cursor"
version = "0.29.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6865c6b66f13d6257bef1cd40cbfe8ef2f150fb8ebbdb1e8e873455931377661"
dependencies = [
 "nix 0.24.3",
 "wayland-client",
 "xcursor",
]

[[package]]
name = "wayland-protocols"
version = "0.29.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b950621f9354b322ee817a23474e479b34be96c2e909c14f7bc0100e9a970bc6"
dependencies = [
 "bitflags 1.3.2",
 "wayland-client",
 "wayland-commons",
 "wayland-scanner",
]

[[package]]
name = "wayland-scanner"
version = "0.29.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8f4303d8fa22ab852f789e75a967f0a2cdc430a607751c0499bada3e451cbd53"
dependencies = [
 "proc-macro2",
 "quote",
 "xml-rs",
]

[[package]]
name = "wayland-sys"
version = "0.29.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "be12ce1a3c39ec7dba25594b97b42cb3195d54953ddb9d3d95a7c3902bc6e9d4"
dependencies = [
 "dlib",
 "lazy_static",
 "pkg-config",
]

[[package]]
name = "web-sys"
version = "0.3.72"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f6488b90108c040df0fe62fa815cbdee25124641df01814dd7282749234c6112"
dependencies = [
 "js-sys",
 "wasm-bindgen",
]

[[package]]
name = "wgpu"
version = "0.16.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "480c965c9306872eb6255fa55e4b4953be55a8b64d57e61d7ff840d3dcc051cd"
dependencies = [
 "arrayvec",
 "cfg-if",
 "js-sys",
 "log",
 "naga",
 "parking_lot",
 "profiling",
 "raw-window-handle",
 "smallvec",
 "static_assertions",
 "wasm-bindgen",
 "wasm-bindgen-futures",
 "web-sys",
 "wgpu-core",
 "wgpu-hal",
 "wgpu-types",
]

[[package]]
name = "wgpu-core"
version = "0.16.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8f478237b4bf0d5b70a39898a66fa67ca3a007d79f2520485b8b0c3dfc46f8c2"
dependencies = [
 "arrayvec",
 "bit-vec",
 "bitflags 2.10.0",
 "codespan-reporting",
 "log",
 "naga",
 "parking_lot",
 "profiling",
 "raw-window-handle",
 "rustc-hash",
 "smallvec",
 "thiserror",
 "web-sys",
 "wgpu-hal",
 "wgpu-types",
]

[[package]]
name = "wgpu-hal"
version = "0.16.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1ecb3258078e936deee14fd4e0febe1cfe9bbb5ffef165cb60218d2ee5eb4448"
dependencies = [
 "android_system_properties",
 "arrayvec",
 "ash",
 "bit-set",
 "bitflags 2.10.0",
 "block",
 "core-graphics-types",
 "d3d12",
 "foreign-types",
 "glow",
 "gpu-alloc",
 "gpu-allocator",
 "gpu-descriptor",
 "hassle-rs",
 "js-sys",
 "khronos-egl",
 "libc",
 "libloading 0.8.9",
 "log",
 "metal",
 "naga",
 "objc",
 "parking_lot",
 "profiling",
 "range-alloc",
 "raw-window-handle",
 "renderdoc-sys",
 "rustc-hash",
 "smallvec",
 "thiserror",
 "wasm-bindgen",
 "web-sys",
 "wgpu-types",
 "winapi",
]

[[package]]
name = "wgpu-types"
version = "0.16.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d0c153280bb108c2979eb5c7391cb18c56642dd3c072e55f52065e13e2a1252a"
dependencies = [
 "bitflags 2.10.0",
 "js-sys",
 "web-sys",
]

[[package]]
name = "widestring"
version = "1.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72069c3113ab32ab29e5584db3c6ec55d416895e60715417b5b883a357c3e471"

[[package]]
name = "winapi"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419"
dependencies = [
 "winapi-i686-pc-windows-gnu",
 "winapi-x86_64-pc-windows-gnu",
]

[[package]]
name = "winapi-i686-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"

[[package]]
name = "winapi-util"
version = "0.1.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c2a7b1c03c876122aa43f3020e6c3c3ee5c05081c9a00739faf7503aeba10d22"
dependencies = [
 "windows-sys 0.61.2",
]

[[package]]
name = "winapi-x86_64-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"

[[package]]
name = "windows"
version = "0.44.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9e745dab35a0c4c77aa3ce42d595e13d2003d6902d6b08c9ef5fc326d08da12b"
dependencies = [
 "windows-targets 0.42.2",
]

[[package]]
name = "windows-link"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f0805222e57f7521d6a62e36fa9163bc891acd422f971defe97d64e70d0a4fe5"

[[package]]
name = "windows-sys"
version = "0.45.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "75283be5efb2831d37ea142365f009c02ec203cd29a3ebecbc093d52315b66d0"
dependencies = [
 "windows-targets 0.42.2",
]

[[package]]
name = "windows-sys"
version = "0.48.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "677d2418bec65e3338edb076e806bc1ec15693c5d0104683f2efe857f61056a9"
dependencies = [
 "windows-targets 0.48.5",
]

[[package]]
name = "windows-sys"
version = "0.61.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ae137229bcbd6cdf0f7b80a31df61766145077ddf49416a728b02cb3921ff3fc"
dependencies = [
 "windows-link",
]

[[package]]
name = "windows-targets"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e5180c00cd44c9b1c88adb3693291f1cd93605ded80c250a75d472756b4d071"
dependencies = [
 "windows_aarch64_gnullvm 0.42.2",
 "windows_aarch64_msvc 0.42.2",
 "windows_i686_gnu 0.42.2",
 "windows_i686_msvc 0.42.2",
 "windows_x86_64_gnu 0.42.2",
 "windows_x86_64_gnullvm 0.42.2",
 "windows_x86_64_msvc 0.42.2",
]

[[package]]
name = "windows-targets"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9a2fa6e2155d7247be68c096456083145c183cbbbc2764150dda45a87197940c"
dependencies = [
 "windows_aarch64_gnullvm 0.48.5",
 "windows_aarch64_msvc 0.48.5",
 "windows_i686_gnu 0.48.5",
 "windows_i686_msvc 0.48.5",
 "windows_x86_64_gnu 0.48.5",
 "windows_x86_64_gnullvm 0.48.5",
 "windows_x86_64_msvc 0.48.5",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "597a5118570b68bc08d8d59125332c54f1ba9d9adeedeef5b99b02ba2b0698f8"

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2b38e32f0abccf9987a4e3079dfb67dcd799fb61361e53e2882c3cbaf0d905d8"

[[package]]
name = "windows_aarch64_msvc"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e08e8864a60f06ef0d0ff4ba04124db8b0fb3be5776a5cd47641e942e58c4d43"

[[package]]
name = "windows_aarch64_msvc"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dc35310971f3b2dbbf3f0690a219f40e2d9afcf64f9ab7cc1be722937c26b4bc"

[[package]]
name = "windows_i686_gnu"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c61d927d8da41da96a81f029489353e68739737d3beca43145c8afec9a31a84f"

[[package]]
name = "windows_i686_gnu"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a75915e7def60c94dcef72200b9a8e58e5091744960da64ec734a6c6e9b3743e"

[[package]]
name = "windows_i686_msvc"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "44d840b6ec649f480a41c8d80f9c65108b92d89345dd94027bfe06ac444d1060"

[[package]]
name = "windows_i686_msvc"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8f55c233f70c4b27f66c523580f78f1004e8b5a8b659e05a4eb49d4166cca406"

[[package]]
name = "windows_x86_64_gnu"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8de912b8b8feb55c064867cf047dda097f92d51efad5b491dfb98f6bbb70cb36"

[[package]]
name = "windows_x86_64_gnu"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "53d40abd2583d23e4718fddf1ebec84dbff8381c07cae67ff7768bbf19c6718e"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "26d41b46a36d453748aedef1486d5c7a85db22e56aff34643984ea85514e94a3"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b7b52767868a23d5bab768e390dc5f5c55825b6d30b86c844ff2dc7414044cc"

[[package]]
name = "windows_x86_64_msvc"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9aec5da331524158c6d1a4ac0ab1541149c0b9505fde06423b02f5ef0106b9f0"

[[package]]
name = "windows_x86_64_msvc"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ed94fce61571a4006852b7389a063ab983c02eb1bb37b47f8272ce92d06d9538"

[[package]]
name = "winit"
version = "0.28.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9596d90b45384f5281384ab204224876e8e8bf7d58366d9b795ad99aa9894b94"
dependencies = [
 "android-activity",
 "bitflags 1.3.2",
 "cfg_aliases",
 "core-foundation",
 "core-graphics",
 "dispatch",
 "instant",
 "libc",
 "log",
 "mio",
 "ndk",
 "objc2",
 "once_cell",
 "orbclient",
 "percent-encoding",
 "raw-window-handle",
 "redox_syscall 0.3.5",
 "sctk-adwaita",
 "smithay-client-toolkit",
 "wasm-bindgen",
 "wayland-client",
 "wayland-commons",
 "wayland-protocols",
 "wayland-scanner",
 "web-sys",
 "windows-sys 0.45.0",
 "x11-dl",
]

[[package]]
name = "winnow"
version = "0.5.40"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f593a95398737aeed53e489c785df13f3618e41dbcd6718c6addbf1395aa6876"
dependencies = [
 "memchr",
]

[[package]]
name = "wit-bindgen"
version = "0.46.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f17a85883d4e6d00e8a97c586de764dabcc06133f7f1d55dce5cdc070ad7fe59"

[[package]]
name = "x11-dl"
version = "2.21.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "38735924fedd5314a6e548792904ed8c6de6636285cb9fec04d5b1db85c1516f"
dependencies = [
 "libc",
 "once_cell",
 "pkg-config",
]

[[package]]
name = "xcursor"
version = "0.3.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bec9e4a500ca8864c5b47b8b482a73d62e4237670e5b5f1d6b9e3cae50f28f2b"

[[package]]
name = "xml-rs"
version = "0.8.28"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3ae8337f8a065cfc972643663ea4279e04e7256de865aa66fe25cec5fb912d3f"

[[package]]
name = "zerocopy"
version = "0.8.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fd74ec98b9250adb3ca554bdde269adf631549f51d8a8f8f0a10b50f1cb298c3"
dependencies = [
 "zerocopy-derive",
]

[[package]]
name = "zerocopy-derive"
version = "0.8.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d8a8d209fdf45cf5138cbb5a506f6b52522a25afccc534d1475dad8e31105c6a"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.113",
]

===== FILE: README.md =====
# U-VR

**U-VR** is a minimal third-person 3D prototype built in **Rust + wgpu + winit**. It focuses on establishing a clean, extensible foundation for movement, camera control, and rendering without the overhead of a heavy game engine.

This repository prioritizes **architectural correctness** and **input separation**, making it a solid baseline for engine development, physics experimentation, or custom game logic.

---

## üöÄ Current Features

### üé• Camera System

* **Orbit Camera:** Traditional third-person behavior.
* **Mouse Interaction:** Orbital rotation (Middle Mouse) and smooth zooming (Scroll).
* **Clamped Pitch:** Prevents gimbal lock or unnatural flipping.
* **Decoupled Logic:** The camera follows the player position but maintains its own independent orientation.

### üèÉ Player Movement

* **Camera-Relative WASD:** Movement is calculated based on the camera‚Äôs current yaw.
* **Directional Alignment:** Player avatar (cube) rotates to face the direction of movement.
* **Verticality:** Jump mechanics with gravity and grounded detection.

### üõ†Ô∏è Rendering & Architecture

* **wgpu Pipeline:** Modern, explicit graphics API usage.
* **Input Separation:** Clean boundaries between raw window events, movement logic, and camera state.
* **Spatial Reference:** Includes a procedural grid-based ground plane for depth perception.

---

## üéÆ Controls

| Input | Action |
| --- | --- |
| **W / A / S / D** | Move (relative to camera) |
| **Space** | Jump |
| **Middle Mouse (Hold)** | Rotate Camera |
| **Mouse Wheel** | Zoom In/Out |
| **Esc / Window Close** | Exit Application |

---

## üìÇ Project Structure

```text
U-VR/
‚îú‚îÄ‚îÄ game/
‚îÇ   ‚îî‚îÄ‚îÄ client/
‚îÇ       ‚îî‚îÄ‚îÄ src/
‚îÇ           ‚îî‚îÄ‚îÄ main.rs         # Entry point (Thin layer)
‚îî‚îÄ‚îÄ engine/
    ‚îî‚îÄ‚îÄ render/
        ‚îî‚îÄ‚îÄ src/
            ‚îú‚îÄ‚îÄ app.rs          # Event loop & Input orchestration
            ‚îî‚îÄ‚îÄ renderer/
                ‚îú‚îÄ‚îÄ mod.rs      # Player movement & Physics state
                ‚îú‚îÄ‚îÄ frame/      # Per-frame rendering logic
                ‚îú‚îÄ‚îÄ uniforms/   # Camera buffers & GPU data
                ‚îú‚îÄ‚îÄ resources/  # Procedural mesh generation
                ‚îî‚îÄ‚îÄ pipeline/   # wgpu pipeline configuration

```

---

## üß† Design Philosophy

1. **No Magic:** Every transformation is explicit; no hidden engine "black boxes."
2. **Input as Data:** Movement and Camera systems consume input data rather than owning it.
3. **Independence:** The camera never infers intent from movement keys.
4. **Clarity over Abstraction:** CPU-side correctness is prioritized over premature GPU optimizations.

---

## üõ† Building & Running

### Requirements

* **Rust** (Stable)
* **GPU:** Vulkan, DX12, or Metal capable hardware.
* **OS:** Windows, Linux, or macOS.

### Execution

```bash
# Run the client application
cargo run --bin client

```

---

## üìà Roadmap & Extensions

* [ ] **Camera Damping:** Add interpolation for smoother motion.
* [ ] **Collision:** Prevent camera/player clipping through geometry.
* [ ] **Character Controller:** Transition from a simple cube to a capsule controller.
* [ ] **Instancing:** Optimized rendering for many objects.
* [ ] **Physics Integration:** Plug in a crate like `rapier3d`.

---

## ‚öñÔ∏è License

Distributed under the **MIT License**. See `LICENSE` for more information.

---

**Status:** üü¢ *Stable baseline. Architecturally decoupled and ready for expansion.*

===== FILE: cargo.toml =====
[workspace]
resolver = "2"

members = [
    "engine/core",
    "engine/net",
    "engine/render",
    "engine/platform",
    "game/client",
    "game/server"
]

===== FILE: engine/core/cargo.toml =====
[package]
name = "core"
version = "0.1.0"
edition = "2021"

[dependencies]
# Core-specific dependencies (if any) go here

===== FILE: engine/core/src/lib.rs =====
pub struct EntityId(pub u64);

pub struct Transform {
    pub position: [f32; 3],
    pub rotation: [f32; 4],
    pub scale: [f32; 3],
}

pub struct Renderable {
    pub mesh: u32,
    pub material: u32,
}

pub struct Script {
    pub script_handle: u32,
}

// Core ECS and world logic will go here.

===== FILE: engine/net/cargo.toml =====
[package]
name = "net"
version = "0.1.0"
edition = "2021"

[dependencies]
core = { path = "../core" }

===== FILE: engine/net/src/lib.rs =====
#[derive(Debug, Clone, Copy)]
pub struct Transform {
    pub position: [f32; 3],
    pub rotation: [f32; 4],
    pub scale: [f32; 3],
}

#[derive(Debug, Clone, Copy)]
pub struct EntityId(pub u64);

===== FILE: engine/platform/cargo.toml =====
[package]
name = "platform"
version = "0.1.0"
edition = "2021"

[dependencies]
# Platform-specific dependencies (if any)

===== FILE: engine/platform/src/lib.rs =====
// Platform-specific windowing, input, and audio abstractions.
pub fn create_window() {
    // Create a window using winit or similar.
}

// Additional platform-layer code.

===== FILE: engine/render/cargo.toml =====
[package]
name = "render"
version = "0.1.0"
edition = "2021"

[dependencies]
wgpu = "0.16.3"
winit = "0.28"
pollster = "0.3"
bytemuck = { version = "1.13", features = ["derive"] }
glam = "0.25"

===== FILE: engine/render/src/app.rs =====
use std::collections::HashSet;
use std::time::Instant;

use glam::Vec3;
use winit::{
    event::*,
    event_loop::{ControlFlow, EventLoop},
    window::{CursorGrabMode, WindowBuilder},
};

use crate::renderer::Renderer;

pub fn run() {
    let event_loop = EventLoop::new();
    let window = WindowBuilder::new()
        .with_title("U-VR")
        .build(&event_loop)
        .unwrap();

    let mut renderer = pollster::block_on(Renderer::new(&window));

    let mut pressed = HashSet::new();
    let mut last_frame = Instant::now();

    let mut jump_requested = false;

    let mut mouse_dx = 0.0f32;
    let mut mouse_dy = 0.0f32;
    let mut scroll = 0.0f32;
    let mut middle_mouse_held = false;

    event_loop.run(move |event, _, control_flow| {
        *control_flow = ControlFlow::Poll;

        match event {
            Event::WindowEvent { event, .. } => match event {
                WindowEvent::CloseRequested => *control_flow = ControlFlow::Exit,

                WindowEvent::Resized(size) => {
                    renderer.resize(size.width, size.height);
                }

                WindowEvent::KeyboardInput { input, .. } => {
                    if let Some(key) = input.virtual_keycode {
                        match input.state {
                            ElementState::Pressed => {
                                if key == VirtualKeyCode::Space {
                                    jump_requested = true;
                                }
                                pressed.insert(key);
                            }
                            ElementState::Released => {
                                pressed.remove(&key);
                            }
                        }
                    }
                }

                WindowEvent::MouseInput { state, button, .. } => {
                    if button == MouseButton::Middle {
                        middle_mouse_held = state == ElementState::Pressed;

                        if middle_mouse_held {
                            let _ = window.set_cursor_grab(CursorGrabMode::Confined);
                            window.set_cursor_visible(false);
                        } else {
                            let _ = window.set_cursor_grab(CursorGrabMode::None);
                            window.set_cursor_visible(true);
                        }
                    }
                }

                WindowEvent::MouseWheel { delta, .. } => {
                    let amount = match delta {
                        MouseScrollDelta::LineDelta(_, y) => y,
                        MouseScrollDelta::PixelDelta(p) => p.y as f32 * 0.01,
                    };
                    scroll += amount;
                }

                _ => {}
            },

            Event::DeviceEvent { event, .. } => match event {
                DeviceEvent::MouseMotion { delta } => {
                    if middle_mouse_held {
                        mouse_dx += delta.0 as f32;
                        mouse_dy += delta.1 as f32;
                    }
                }
                _ => {}
            },

            Event::MainEventsCleared => {
                let now = Instant::now();
                let dt = (now - last_frame).as_secs_f32();
                last_frame = now;

                let mut input = Vec3::ZERO;

                if pressed.contains(&VirtualKeyCode::W) {
                    input.z -= 1.0;
                }
                if pressed.contains(&VirtualKeyCode::S) {
                    input.z += 1.0;
                }
                if pressed.contains(&VirtualKeyCode::A) {
                    input.x -= 1.0;
                }
                if pressed.contains(&VirtualKeyCode::D) {
                    input.x += 1.0;
                }

                renderer.camera.handle_mouse(
                    mouse_dx,
                    mouse_dy,
                    scroll,
                    middle_mouse_held,
                );

                mouse_dx = 0.0;
                mouse_dy = 0.0;
                scroll = 0.0;

                renderer.update(dt, input, jump_requested);
                jump_requested = false;

                window.request_redraw();
            }

            Event::RedrawRequested(_) => {
                renderer.render();
            }

            _ => {}
        }
    });
}

===== FILE: engine/render/src/avatar/avatar.rs =====
use glam::Vec3;

pub struct Avatar {
    pub position: Vec3,
    pub yaw: f32,
    pub scale: Vec3,
}

impl Avatar {
    pub fn new() -> Self {
        Self {
            position: Vec3::ZERO,
            yaw: 0.0,
            scale: Vec3::ONE,
        }
    }
}

===== FILE: engine/render/src/avatar/capsule.rs =====
use glam::Vec3;

#[derive(Clone, Copy)]
pub struct CapsulePart {
    pub offset: Vec3,
    pub scale: Vec3,
}

pub struct CapsuleAvatar {
    pub parts: Vec<CapsulePart>,
}

impl CapsuleAvatar {
    pub fn humanoid() -> Self {
        let mut parts = Vec::new();

        // ===== BODY =====
        parts.push(CapsulePart {
            offset: Vec3::new(0.0, 0.9, 0.0),
            scale: Vec3::new(0.6, 1.2, 0.4),
        });

        // ===== HEAD =====
        parts.push(CapsulePart {
            offset: Vec3::new(0.0, 1.7, 0.0),
            scale: Vec3::new(0.45, 0.45, 0.45),
        });

        // ===== LOWER BODY =====
        parts.push(CapsulePart {
            offset: Vec3::new(0.0, 0.35, 0.0),
            scale: Vec3::new(0.5, 0.6, 0.35),
        });

        Self { parts }
    }
}

===== FILE: engine/render/src/avatar/definition.rs =====
use glam::Vec3;

#[derive(Clone)]
pub struct AvatarDefinition {
    pub scale: f32,
    pub parts: Vec<AvatarPartDef>,
}

#[derive(Clone)]
pub struct AvatarPartDef {
    pub name: &'static str,
    pub local_offset: Vec3,
    pub size: Vec3,
}

===== FILE: engine/render/src/avatar/loader.rs =====
use glam::Vec3;
use super::definition::*;

pub fn load_default_avatar() -> AvatarDefinition {
    AvatarDefinition {
        scale: 1.0,
        parts: vec![
            AvatarPartDef {
                name: "head",
                local_offset: Vec3::new(0.0, 1.6, 0.0),
                size: Vec3::splat(0.4),
            },
            AvatarPartDef {
                name: "body",
                local_offset: Vec3::new(0.0, 1.0, 0.0),
                size: Vec3::new(0.5, 0.7, 0.3),
            },
            AvatarPartDef {
                name: "legs",
                local_offset: Vec3::new(0.0, 0.4, 0.0),
                size: Vec3::new(0.4, 0.8, 0.3),
            },
        ],
    }
}

===== FILE: engine/render/src/avatar/mesh.rs =====
use glam::Vec3;

#[derive(Clone, Copy)]
pub struct Vertex {
    pub position: Vec3,
    pub normal: Vec3,
}

pub struct Mesh {
    pub vertices: Vec<Vertex>,
    pub indices: Vec<u32>,
}

===== FILE: engine/render/src/avatar/mod.rs =====
pub mod capsule;

pub use capsule::{CapsuleAvatar, CapsulePart};

===== FILE: engine/render/src/avatar/part.rs =====
use glam::Vec3;

#[derive(Clone)]
pub struct AvatarPart {
    pub name: &'static str,
    pub offset: Vec3,
    pub size: Vec3,
}

===== FILE: engine/render/src/lib.rs =====
pub mod app;
pub mod renderer;
pub mod avatar;

===== FILE: engine/render/src/renderer/context/depth.rs =====
pub struct DepthTexture {
    pub view: wgpu::TextureView,
    pub format: wgpu::TextureFormat,
}

impl DepthTexture {
    pub fn new(
        device: &wgpu::Device,
        config: &wgpu::SurfaceConfiguration,
    ) -> Self {
        let format = wgpu::TextureFormat::Depth24Plus;

        let texture = device.create_texture(&wgpu::TextureDescriptor {
            label: Some("depth_texture"),
            size: wgpu::Extent3d {
                width: config.width,
                height: config.height,
                depth_or_array_layers: 1,
            },
            mip_level_count: 1,
            sample_count: 1,
            dimension: wgpu::TextureDimension::D2,
            format,
            usage: wgpu::TextureUsages::RENDER_ATTACHMENT,
            view_formats: &[],
        });

        let view = texture.create_view(&wgpu::TextureViewDescriptor::default());

        Self { view, format }
    }
}

===== FILE: engine/render/src/renderer/context/device.rs =====
use winit::window::Window;

pub struct RenderDevice {
    pub instance: wgpu::Instance,
    pub adapter: wgpu::Adapter,
    pub device: wgpu::Device,
    pub queue: wgpu::Queue,
}

impl RenderDevice {
    pub async fn new(window: &Window) -> Self {
        let instance = wgpu::Instance::default();
        let surface = unsafe { instance.create_surface(window) }.unwrap();

        let adapter = instance
            .request_adapter(&wgpu::RequestAdapterOptions {
                compatible_surface: Some(&surface),
                ..Default::default()
            })
            .await
            .unwrap();

        let (device, queue) =
            adapter.request_device(&wgpu::DeviceDescriptor::default(), None).await.unwrap();

        Self {
            instance,
            adapter,
            device,
            queue,
        }
    }
}

===== FILE: engine/render/src/renderer/context/mod.rs =====
use winit::window::Window;

pub mod device;
pub mod surface;
pub mod depth;

use crate::renderer::context::device::RenderDevice;
use crate::renderer::context::surface::RenderSurface;
use crate::renderer::context::depth::DepthTexture;

pub struct RenderContext {
    pub device: RenderDevice,
    pub surface: RenderSurface,
    pub camera_layout: wgpu::BindGroupLayout,
    pub depth: DepthTexture,
}

impl RenderContext {
    pub async fn new(window: &Window) -> Self {
        let instance = wgpu::Instance::default();

        let adapter = instance
            .request_adapter(&wgpu::RequestAdapterOptions {
                power_preference: wgpu::PowerPreference::HighPerformance,
                compatible_surface: None,
                force_fallback_adapter: false,
            })
            .await
            .expect("failed to find adapter");

        let (device, queue) = adapter
            .request_device(
                &wgpu::DeviceDescriptor {
                    label: None,
                    features: wgpu::Features::empty(),
                    limits: wgpu::Limits::default(),
                },
                None,
            )
            .await
            .expect("failed to create device");

        let render_device = RenderDevice {
            instance,
            adapter,
            device,
            queue,
        };

        let surface = RenderSurface::new(window, &render_device);
        let depth = DepthTexture::new(&render_device.device, &surface.config);

        let camera_layout =
            render_device
                .device
                .create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
                    label: Some("camera_bind_group_layout"),
                    entries: &[
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::VERTEX,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Uniform,
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                });

        Self {
            device: render_device,
            surface,
            camera_layout,
            depth,
        }
    }

    pub fn resize(&mut self, width: u32, height: u32) {
        self.surface.resize(width, height, &self.device);
        self.depth = DepthTexture::new(&self.device.device, &self.surface.config);

    }
}

===== FILE: engine/render/src/renderer/context/surface.rs =====
use winit::window::Window;
use crate::renderer::context::device::RenderDevice;

pub struct RenderSurface {
    pub surface: wgpu::Surface,
    pub config: wgpu::SurfaceConfiguration,
}

impl RenderSurface {
    pub fn new(window: &Window, device: &RenderDevice) -> Self {
        let size = window.inner_size();
        let surface = unsafe { device.instance.create_surface(window) }.unwrap();
        let format = surface.get_capabilities(&device.adapter).formats[0];

        let config = wgpu::SurfaceConfiguration {
            usage: wgpu::TextureUsages::RENDER_ATTACHMENT,
            format,
            width: size.width,
            height: size.height,
            present_mode: wgpu::PresentMode::Fifo,
            alpha_mode: wgpu::CompositeAlphaMode::Auto,
            view_formats: vec![],
        };

        surface.configure(&device.device, &config);

        Self { surface, config }
    }

    pub fn resize(&mut self, width: u32, height: u32, device: &RenderDevice) {
        if width == 0 || height == 0 {
            return;
        }
        self.config.width = width;
        self.config.height = height;
        self.surface.configure(&device.device, &self.config);
    }
}

===== FILE: engine/render/src/renderer/frame/mod.rs =====
pub mod render_pass;
pub mod overlay_pass;

use glam::Vec3;
use crate::renderer::context::RenderContext;
use crate::renderer::uniforms::camera::OrbitCamera;
use crate::renderer::Prop;

pub struct FrameRenderer;

impl FrameRenderer {
    pub fn new(_ctx: &RenderContext) -> Self {
        Self
    }

    pub fn render(
        &mut self,
        ctx: &mut RenderContext,
        camera: &OrbitCamera,
        avatar_pos: Vec3,
        avatar_yaw: f32,
        props: &[Prop],
    ) {
        render_pass::render_frame(ctx, camera, avatar_pos, avatar_yaw, props);
    }
}

===== FILE: engine/render/src/renderer/frame/overlay_pass.rs =====
use glam::{Mat3, Vec3};

use crate::renderer::resources::mesh::{Mesh, Vertex};

pub fn draw_compass_overlay(
    encoder: &mut wgpu::CommandEncoder,
    view: &wgpu::TextureView,
    device: &wgpu::Device,
    pipeline: &wgpu::RenderPipeline,
    camera_yaw: f32,
) {
    // Length of axis
    let length = 0.18;

    // THICKNESS CONTROL (increase this to make it thicker)
    let thickness = 0.1;

    // Bottom-right of screen in NDC-ish space
    let origin = Vec3::new(0.85, -0.85, 0.0);

    let rot = Mat3::from_rotation_y(-camera_yaw);

    let axes = [
        (Vec3::X, [1.0, 0.0, 0.0]), // X = red
        (Vec3::Y, [0.0, 1.0, 0.0]), // Y = green
        (Vec3::Z, [0.0, 0.0, 1.0]), // Z = blue
    ];

    let mut vertices = Vec::new();
    let mut indices = Vec::new();
    let mut i: u16 = 0;

    for (axis, color) in axes {
        let dir = rot * axis * length;

        // Perpendicular vector for thickness (screen-space)
        let perp = Vec3::new(-dir.y, dir.x, 0.0)
            .normalize_or_zero()
            * thickness;

        // Quad corners
        let p0 = origin + perp;
        let p1 = origin - perp;
        let p2 = origin + dir - perp;
        let p3 = origin + dir + perp;

        vertices.push(Vertex { position: p0.into(), color });
        vertices.push(Vertex { position: p1.into(), color });
        vertices.push(Vertex { position: p2.into(), color });
        vertices.push(Vertex { position: p3.into(), color });

        // Two triangles
        indices.extend_from_slice(&[
            i, i + 1, i + 2,
            i, i + 2, i + 3,
        ]);

        i += 4;
    }

    let mesh = Mesh::new(device, &vertices, &indices);

    let mut pass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
        label: Some("compass_overlay_pass"),
        color_attachments: &[Some(wgpu::RenderPassColorAttachment {
            view,
            resolve_target: None,
            ops: wgpu::Operations {
                load: wgpu::LoadOp::Load,
                store: true,
            },
        })],
        depth_stencil_attachment: None,
    });

    pass.set_pipeline(pipeline);
    mesh.draw(&mut pass);
}

===== FILE: engine/render/src/renderer/frame/render_pass.rs =====
use glam::{Mat3, Mat4, Vec3};
use wgpu::util::DeviceExt;

use crate::renderer::context::RenderContext;
use crate::renderer::pipeline::RenderPipelineBundle;
use crate::renderer::resources::mesh::{Mesh, Vertex, floor_mesh, cube_mesh};
use crate::renderer::uniforms::camera::{CameraUniform, OrbitCamera};
use crate::renderer::frame::overlay_pass::draw_compass_overlay;
use crate::renderer::Prop;

/* =========================================================
   ENTRY POINT
   ========================================================= */

pub fn render_frame(
    ctx: &mut RenderContext,
    camera: &OrbitCamera,
    avatar_pos: Vec3,
    avatar_yaw: f32,
    props: &[Prop],
) {
    let frame = ctx.surface.surface.get_current_texture().unwrap();
    let view = frame
        .texture
        .create_view(&wgpu::TextureViewDescriptor::default());

    let mut encoder = ctx.device.device.create_command_encoder(
        &wgpu::CommandEncoderDescriptor {
            label: Some("frame_encoder"),
        },
    );

    /* =====================================================
       CAMERA UNIFORM
       ===================================================== */

    let view_m = camera.view_matrix();
    let proj_m = Mat4::perspective_rh(
        45.0_f32.to_radians(),
        ctx.surface.config.width as f32 / ctx.surface.config.height as f32,
        0.1,
        100.0,
    );

    let cam = CameraUniform {
        view_proj: (proj_m * view_m).to_cols_array_2d(),
    };

    let camera_buffer = ctx.device.device.create_buffer_init(
        &wgpu::util::BufferInitDescriptor {
            label: Some("camera_buffer"),
            contents: bytemuck::bytes_of(&cam),
            usage: wgpu::BufferUsages::UNIFORM,
        },
    );

    let camera_bind_group = ctx.device.device.create_bind_group(
        &wgpu::BindGroupDescriptor {
            layout: &ctx.camera_layout,
            entries: &[wgpu::BindGroupEntry {
                binding: 0,
                resource: camera_buffer.as_entire_binding(),
            }],
            label: None,
        },
    );

    /* =====================================================
       PIPELINES
       ===================================================== */

    let pipeline = RenderPipelineBundle::new(
        &ctx.device,
        &ctx.surface.config,
        &ctx.camera_layout,
    );

    /* =====================================================
       BUILD MESHES
       ===================================================== */

    let (fv, fi) = floor_mesh();
    let floor = Mesh::new(&ctx.device.device, &fv, &fi);

    let (mut av, ai) = cube_mesh([0.8, 0.8, 0.8]);
    let rot = Mat3::from_rotation_y(avatar_yaw);
    let scale = Vec3::new(1.0, 2.0, 1.0);

    for v in &mut av {
        let p = Vec3::from(v.position);
        v.position = (rot * (p * scale) + avatar_pos).into();
    }

    let avatar = Mesh::new(&ctx.device.device, &av, &ai);

    let mut prop_meshes = Vec::new();
    for prop in props {
        let (mut pv, pi) = cube_mesh([0.3, 0.6, 0.9]);
        for v in &mut pv {
            let p = Vec3::from(v.position) * prop.scale + prop.position;
            v.position = p.into();
        }
        prop_meshes.push(Mesh::new(&ctx.device.device, &pv, &pi));
    }

    /* =====================================================
       PASS 1 ‚Äî WORLD
       ===================================================== */

    {
        let mut pass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
            label: Some("world_pass"),
            color_attachments: &[Some(wgpu::RenderPassColorAttachment {
                view: &view,
                resolve_target: None,
                ops: wgpu::Operations {
                    load: wgpu::LoadOp::Clear(wgpu::Color::BLACK),
                    store: true,
                },
            })],
            depth_stencil_attachment: Some(wgpu::RenderPassDepthStencilAttachment {
    view: &ctx.depth.view,
    depth_ops: Some(wgpu::Operations {
        load: wgpu::LoadOp::Clear(1.0),
        store: true,
    }),
    stencil_ops: None,
}),

        });

        pass.set_pipeline(&pipeline.main);
        pass.set_bind_group(0, &camera_bind_group, &[]);

        floor.draw(&mut pass);
        avatar.draw(&mut pass);

        for m in &prop_meshes {
            m.draw(&mut pass);
        }
    }

    /* =====================================================
       PASS 2 ‚Äî COMPASS OVERLAY (SCREEN SPACE)
       ===================================================== */

    draw_compass_overlay(
        &mut encoder,
        &view,
        &ctx.device.device,
        &pipeline.overlay,
        camera.yaw,
    );

    /* =====================================================
       SUBMIT
       ===================================================== */

    ctx.device.queue.submit(Some(encoder.finish()));
    frame.present();
}

===== FILE: engine/render/src/renderer/mod.rs =====
use glam::Vec3;
use winit::window::Window;

use context::RenderContext;
use frame::FrameRenderer;

pub mod context;
pub mod frame;
pub mod pipeline;
pub mod resources;
pub mod uniforms;

use uniforms::camera::OrbitCamera;

#[derive(Clone, Copy)]
pub struct Prop {
    pub position: Vec3,
    pub scale: Vec3,
}

pub struct Renderer {
    ctx: RenderContext,
    frame: FrameRenderer,

    // ===== AVATAR STATE =====
    avatar_pos: Vec3,
    avatar_yaw: f32,
    velocity: Vec3,
    grounded: bool,

    // ===== DOUBLE JUMP =====
    jump_count: u8,
    max_jumps: u8,

    // ===== CAMERA =====
    pub camera: OrbitCamera,

    // ===== AVATAR GEOMETRY (LOCAL SPACE) =====
    avatar_parts: Vec<Prop>,
}

impl Renderer {
    pub async fn new(window: &Window) -> Self {
        let ctx = RenderContext::new(window).await;
        let frame = FrameRenderer::new(&ctx);

        // Composite avatar built from parts (local-space)
        let avatar_parts = vec![
            // Torso
            Prop {
                position: Vec3::new(0.0, 0.9, 0.0),
                scale: Vec3::new(0.6, 0.9, 0.3),
            },
            // Head
            Prop {
                position: Vec3::new(0.0, 1.6, 0.0),
                scale: Vec3::splat(0.35),
            },
            // Left leg
            Prop {
                position: Vec3::new(-0.15, 0.3, 0.0),
                scale: Vec3::new(0.2, 0.6, 0.2),
            },
            // Right leg
            Prop {
                position: Vec3::new(0.15, 0.3, 0.0),
                scale: Vec3::new(0.2, 0.6, 0.2),
            },
        ];

        Self {
            ctx,
            frame,
            avatar_pos: Vec3::ZERO,
            avatar_yaw: 0.0,
            velocity: Vec3::ZERO,
            grounded: true,

            jump_count: 0,
            max_jumps: 2,

            camera: OrbitCamera::new(),
            avatar_parts,
        }
    }

    pub fn resize(&mut self, width: u32, height: u32) {
        self.ctx.resize(width, height);
    }

    pub fn update(&mut self, dt: f32, input: Vec3, jump: bool) {
        let speed = 4.0;

        let yaw = self.camera.yaw;
        let forward = Vec3::new(yaw.sin(), 0.0, yaw.cos());
        let right = Vec3::new(forward.z, 0.0, -forward.x);

        let mut move_dir = Vec3::ZERO;
        move_dir += forward * -input.z;
        move_dir += right * -input.x;

        if move_dir.length_squared() > 0.0001 {
            move_dir = move_dir.normalize();
            self.avatar_yaw = move_dir.x.atan2(move_dir.z);
            self.avatar_pos += move_dir * speed * dt;
        }

        // ===== DOUBLE JUMP =====
        if jump && self.jump_count < self.max_jumps {
            self.velocity.y = 5.0;
            self.grounded = false;
            self.jump_count += 1;
        }

        // Gravity
        self.velocity.y -= 9.8 * dt;
        self.avatar_pos.y += self.velocity.y * dt;

        // Ground collision
        if self.avatar_pos.y <= 0.0 {
            self.avatar_pos.y = 0.0;
            self.velocity.y = 0.0;
            self.grounded = true;
            self.jump_count = 0;
        }

        self.camera.target = self.avatar_pos;
    }

    pub fn render(&mut self) {
        // Convert avatar parts to world-space props for rendering
        let avatar_world_props: Vec<Prop> = self
            .avatar_parts
            .iter()
            .map(|part| Prop {
                position: self.avatar_pos + part.position,
                scale: part.scale,
            })
            .collect();

        self.frame.render(
            &mut self.ctx,
            &self.camera,
            self.avatar_pos,
            self.avatar_yaw,
            &avatar_world_props,
        );
    }
}

===== FILE: engine/render/src/renderer/objects/avatar.rs =====
use glam::{Mat4, Vec3};

use super::RenderObject;

pub struct Avatar {
    model: Mat4,
}

impl Avatar {
    pub fn new() -> Self {
        Self {
            model: Mat4::IDENTITY,
        }
    }

    pub fn translate(&mut self, delta: Vec3) {
        self.model *= Mat4::from_translation(delta);
    }

    pub fn position(&self) -> Vec3 {
        self.model.w_axis.truncate()
    }
}

impl RenderObject for Avatar {
    fn model_matrix(&self) -> Mat4 {
        self.model
    }

    fn is_floor(&self) -> bool {
        false
    }
}

===== FILE: engine/render/src/renderer/objects/floor.rs =====
use glam::Mat4;

use super::RenderObject;

pub struct Floor {
    model: Mat4,
}

impl Floor {
    pub fn new() -> Self {
        Self {
            model: Mat4::IDENTITY,
        }
    }
}

impl RenderObject for Floor {
    fn model_matrix(&self) -> Mat4 {
        self.model
    }

    fn is_floor(&self) -> bool {
        true
    }
}

===== FILE: engine/render/src/renderer/objects/mod.rs =====
use glam::Mat4;

pub trait RenderObject {
    fn model_matrix(&self) -> Mat4;
    fn is_floor(&self) -> bool;
}

===== FILE: engine/render/src/renderer/overlay/compass.rs =====
use wgpu::util::DeviceExt;
use crate::renderer::pipeline::overlay_pipeline::OverlayVertex;

pub struct Compass {
    buffer: wgpu::Buffer,
    count: u32,
}

impl Compass {
    pub fn new(device: &wgpu::Device) -> Self {
        let origin = [0.82, 0.82];
        let len = 0.10;

        let verts = [
            // X axis (Red)
            OverlayVertex { position: origin, color: [1.0, 0.0, 0.0] },
            OverlayVertex { position: [origin[0] + len, origin[1]], color: [1.0, 0.0, 0.0] },

            // Z axis (Blue)
            OverlayVertex { position: origin, color: [0.0, 0.0, 1.0] },
            OverlayVertex { position: [origin[0], origin[1] + len], color: [0.0, 0.0, 1.0] },
        ];

        let buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("compass_buffer"),
            contents: bytemuck::cast_slice(&verts),
            usage: wgpu::BufferUsages::VERTEX,
        });

        Self {
            buffer,
            count: verts.len() as u32,
        }
    }

    pub fn draw<'a>(&'a self, pass: &mut wgpu::RenderPass<'a>) {
        pass.set_vertex_buffer(0, self.buffer.slice(..));
        pass.draw(0..self.count, 0..1);
    }
}

===== FILE: engine/render/src/renderer/overlay/mod.rs =====
pub mod compass;

===== FILE: engine/render/src/renderer/pipeline/layouts.rs =====
pub struct BindGroupLayouts {
    pub camera: wgpu::BindGroupLayout,
    pub material: wgpu::BindGroupLayout,
}

impl BindGroupLayouts {
    pub fn new(device: &wgpu::Device) -> Self {
        let camera = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
            entries: &[wgpu::BindGroupLayoutEntry {
                binding: 0,
                visibility: wgpu::ShaderStages::VERTEX,
                ty: wgpu::BindingType::Buffer {
                    ty: wgpu::BufferBindingType::Uniform,
                    has_dynamic_offset: false,
                    min_binding_size: None,
                },
                count: None,
            }],
            label: Some("camera_layout"),
        });

        let material = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
            entries: &[wgpu::BindGroupLayoutEntry {
                binding: 0,
                visibility: wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Buffer {
                    ty: wgpu::BufferBindingType::Uniform,
                    has_dynamic_offset: false,
                    min_binding_size: None,
                },
                count: None,
            }],
            label: Some("material_layout"),
        });

        Self { camera, material }
    }
}

===== FILE: engine/render/src/renderer/pipeline/mod.rs =====
use crate::renderer::context::device::RenderDevice;

pub mod pipeline;
pub mod overlay_pipeline;

use pipeline::create_pipeline;
use overlay_pipeline::create_overlay_pipeline;

pub struct RenderPipelineBundle {
    pub main: wgpu::RenderPipeline,
    pub overlay: wgpu::RenderPipeline,
}

impl RenderPipelineBundle {
    pub fn new(
        device: &RenderDevice,
        config: &wgpu::SurfaceConfiguration,
        camera_layout: &wgpu::BindGroupLayout,
    ) -> Self {
        let main = create_pipeline(
            &device.device,
            config,
            camera_layout,
        );

        let overlay = create_overlay_pipeline(
            &device.device,
            config,
        );

        Self { main, overlay }
    }
}

===== FILE: engine/render/src/renderer/pipeline/overlay.wgsl =====
struct VertexInput {
    @location(0) position : vec3<f32>,
    @location(1) color : vec3<f32>,
};

struct VertexOutput {
    @builtin(position) clip_position : vec4<f32>,
    @location(0) color : vec3<f32>,
};

@vertex
fn vs_main(in: VertexInput) -> VertexOutput {
    var out : VertexOutput;

    // position is already in clip-space-like coordinates
    out.clip_position = vec4<f32>(in.position, 1.0);
    out.color = in.color;

    return out;
}

@fragment
fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {
    return vec4<f32>(in.color, 1.0);
}

===== FILE: engine/render/src/renderer/pipeline/overlay_pipeline.rs =====
use crate::renderer::resources::mesh::Vertex;

pub fn create_overlay_pipeline(
    device: &wgpu::Device,
    config: &wgpu::SurfaceConfiguration,
) -> wgpu::RenderPipeline {
    let shader = device.create_shader_module(wgpu::ShaderModuleDescriptor {
        label: Some("overlay_shader"),
        source: wgpu::ShaderSource::Wgsl(include_str!("overlay.wgsl").into()),
    });

    // Overlay pipeline has NO bind groups
    let pipeline_layout =
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("overlay_pipeline_layout"),
            bind_group_layouts: &[],
            push_constant_ranges: &[],
        });

    device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
        label: Some("overlay_pipeline"),
        layout: Some(&pipeline_layout),

        vertex: wgpu::VertexState {
            module: &shader,
            entry_point: "vs_main",
            buffers: &[Vertex::layout()],
        },

        fragment: Some(wgpu::FragmentState {
            module: &shader,
            entry_point: "fs_main",
            targets: &[Some(wgpu::ColorTargetState {
                format: config.format,
                blend: Some(wgpu::BlendState::ALPHA_BLENDING),
                write_mask: wgpu::ColorWrites::ALL,
            })],
        }),

        primitive: wgpu::PrimitiveState {
            topology: wgpu::PrimitiveTopology::LineList, // IMPORTANT for compass
            ..Default::default()
        },

        depth_stencil: None,
        multisample: wgpu::MultisampleState::default(),
        multiview: None,
    })
}

===== FILE: engine/render/src/renderer/pipeline/pipeline.rs =====
use crate::renderer::resources::mesh::Vertex;

pub fn create_pipeline(
    device: &wgpu::Device,
    config: &wgpu::SurfaceConfiguration,
    camera_layout: &wgpu::BindGroupLayout,
) -> wgpu::RenderPipeline {
    let shader = device.create_shader_module(wgpu::ShaderModuleDescriptor {
        label: Some("main_shader"),
        source: wgpu::ShaderSource::Wgsl(include_str!("shader.wgsl").into()),
    });

    let pipeline_layout = device.create_pipeline_layout(
        &wgpu::PipelineLayoutDescriptor {
            label: Some("main_pipeline_layout"),
            bind_group_layouts: &[camera_layout],
            push_constant_ranges: &[],
        },
    );

    device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
        label: Some("main_pipeline"),
        layout: Some(&pipeline_layout),

        vertex: wgpu::VertexState {
            module: &shader,
            entry_point: "vs_main",
            buffers: &[Vertex::layout()],
        },

        fragment: Some(wgpu::FragmentState {
            module: &shader,
            entry_point: "fs_main",
            targets: &[Some(wgpu::ColorTargetState {
                format: config.format,
                blend: Some(wgpu::BlendState::REPLACE),
                write_mask: wgpu::ColorWrites::ALL,
            })],
        }),

        primitive: wgpu::PrimitiveState::default(),
        depth_stencil: Some(wgpu::DepthStencilState {
            format: wgpu::TextureFormat::Depth24Plus,
            depth_write_enabled: true,
            depth_compare: wgpu::CompareFunction::Less,
            stencil: wgpu::StencilState::default(),
            bias: wgpu::DepthBiasState::default(),
        }),

        multisample: wgpu::MultisampleState::default(),
        multiview: None,
    })
}

===== FILE: engine/render/src/renderer/pipeline/shader.wgsl =====
struct VertexInput {
    @location(0) position : vec3<f32>,
    @location(1) color : vec3<f32>,
};

struct VertexOutput {
    @builtin(position) clip_position : vec4<f32>,
    @location(0) color : vec3<f32>,
};

@group(0) @binding(0)
var<uniform> view_proj : mat4x4<f32>;

@vertex
fn vs_main(in: VertexInput) -> VertexOutput {
    var out : VertexOutput;
    out.clip_position = view_proj * vec4<f32>(in.position, 1.0);
    out.color = in.color;
    return out;
}

@fragment
fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {
    return vec4<f32>(in.color, 1.0);
}

===== FILE: engine/render/src/renderer/resources/axis.rs =====
use crate::renderer::resources::mesh::Vertex;

pub fn axis_mesh() -> (Vec<Vertex>, Vec<u16>) {
    let len = 0.6;

    let vertices = vec![
        // X axis (red)
        Vertex { position: [0.0, 0.0, 0.0], color: [1.0, 0.0, 0.0] },
        Vertex { position: [len, 0.0, 0.0], color: [1.0, 0.0, 0.0] },

        // Y axis (green)
        Vertex { position: [0.0, 0.0, 0.0], color: [0.0, 1.0, 0.0] },
        Vertex { position: [0.0, len, 0.0], color: [0.0, 1.0, 0.0] },

        // Z axis (blue)
        Vertex { position: [0.0, 0.0, 0.0], color: [0.0, 0.0, 1.0] },
        Vertex { position: [0.0, 0.0, len], color: [0.0, 0.0, 1.0] },
    ];

    let indices = vec![0,1, 2,3, 4,5];
    (vertices, indices)
}

===== FILE: engine/render/src/renderer/resources/mesh.rs =====
use bytemuck::{Pod, Zeroable};
use wgpu::util::DeviceExt;

/* =========================================================
   VERTEX
   ========================================================= */

#[repr(C)]
#[derive(Copy, Clone, Pod, Zeroable)]
pub struct Vertex {
    pub position: [f32; 3],
    pub color: [f32; 3],
}

impl Vertex {
    pub fn layout() -> wgpu::VertexBufferLayout<'static> {
        wgpu::VertexBufferLayout {
            array_stride: std::mem::size_of::<Vertex>() as wgpu::BufferAddress,
            step_mode: wgpu::VertexStepMode::Vertex,
            attributes: &[
                // position
                wgpu::VertexAttribute {
                    offset: 0,
                    shader_location: 0,
                    format: wgpu::VertexFormat::Float32x3,
                },
                // color
                wgpu::VertexAttribute {
                    offset: 12,
                    shader_location: 1,
                    format: wgpu::VertexFormat::Float32x3,
                },
            ],
        }
    }
}

/* =========================================================
   MESH
   ========================================================= */

pub struct Mesh {
    pub vertex_buffer: wgpu::Buffer,
    pub index_buffer: wgpu::Buffer,
    pub index_count: u32,
}

impl Mesh {
    pub fn new(
        device: &wgpu::Device,
        vertices: &[Vertex],
        indices: &[u16],
    ) -> Self {
        let vertex_buffer = device.create_buffer_init(
            &wgpu::util::BufferInitDescriptor {
                label: Some("vertex_buffer"),
                contents: bytemuck::cast_slice(vertices),
                usage: wgpu::BufferUsages::VERTEX,
            },
        );

        let index_buffer = device.create_buffer_init(
            &wgpu::util::BufferInitDescriptor {
                label: Some("index_buffer"),
                contents: bytemuck::cast_slice(indices),
                usage: wgpu::BufferUsages::INDEX,
            },
        );

        Self {
            vertex_buffer,
            index_buffer,
            index_count: indices.len() as u32,
        }
    }

    pub fn draw<'a>(&'a self, pass: &mut wgpu::RenderPass<'a>) {
        pass.set_vertex_buffer(0, self.vertex_buffer.slice(..));
        pass.set_index_buffer(self.index_buffer.slice(..), wgpu::IndexFormat::Uint16);
        pass.draw_indexed(0..self.index_count, 0, 0..1);
    }
}

/* =========================================================
   GRID FLOOR (LINES)
   ========================================================= */

pub fn floor_mesh() -> (Vec<Vertex>, Vec<u16>) {
    let size: i32 = 20;
    let spacing = 1.0;

    let mut vertices = Vec::new();
    let mut indices = Vec::new();
    let mut i: u16 = 0;

    let grid_color = [0.4, 0.4, 0.4];

    // lines parallel to Z
    for x in -size..=size {
        let x = x as f32 * spacing;

        vertices.push(Vertex {
            position: [x, 0.0, -size as f32 * spacing],
            color: grid_color,
        });
        vertices.push(Vertex {
            position: [x, 0.0, size as f32 * spacing],
            color: grid_color,
        });

        indices.push(i);
        indices.push(i + 1);
        i += 2;
    }

    // lines parallel to X
    for z in -size..=size {
        let z = z as f32 * spacing;

        vertices.push(Vertex {
            position: [-size as f32 * spacing, 0.0, z],
            color: grid_color,
        });
        vertices.push(Vertex {
            position: [size as f32 * spacing, 0.0, z],
            color: grid_color,
        });

        indices.push(i);
        indices.push(i + 1);
        i += 2;
    }

    (vertices, indices)
}

/* =========================================================
   CUBE (TRIANGLES)
   ========================================================= */

pub fn cube_mesh(color: [f32; 3]) -> (Vec<Vertex>, Vec<u16>) {
    let vertices = vec![
        Vertex { position: [-0.5, -0.5, -0.5], color },
        Vertex { position: [ 0.5, -0.5, -0.5], color },
        Vertex { position: [ 0.5,  0.5, -0.5], color },
        Vertex { position: [-0.5,  0.5, -0.5], color },
        Vertex { position: [-0.5, -0.5,  0.5], color },
        Vertex { position: [ 0.5, -0.5,  0.5], color },
        Vertex { position: [ 0.5,  0.5,  0.5], color },
        Vertex { position: [-0.5,  0.5,  0.5], color },
    ];

    let indices: Vec<u16> = vec![
        0, 1, 2, 2, 3, 0,
        4, 5, 6, 6, 7, 4,
        0, 4, 7, 7, 3, 0,
        1, 5, 6, 6, 2, 1,
        3, 2, 6, 6, 7, 3,
        0, 1, 5, 5, 4, 0,
    ];

    (vertices, indices)
}

===== FILE: engine/render/src/renderer/resources/mod.rs =====
pub mod mesh;

===== FILE: engine/render/src/renderer/scene/draw_list.rs =====

===== FILE: engine/render/src/renderer/scene/mod.rs =====

===== FILE: engine/render/src/renderer/scene/scene.rs =====

===== FILE: engine/render/src/renderer/shaders/basic.wgsl =====
struct Camera {
    view_proj: mat4x4<f32>,
};

@group(0) @binding(0)
var<uniform> camera: Camera;

struct Material {
    color: vec4<f32>,
};

@group(1) @binding(0)
var<uniform> material: Material;

struct VSIn {
    @location(0) position: vec3<f32>,
};

struct VSOut {
    @builtin(position) pos: vec4<f32>,
};

@vertex
fn vs_main(input: VSIn) -> VSOut {
    var out: VSOut;
    out.pos = camera.view_proj * vec4<f32>(input.position, 1.0);
    return out;
}

@fragment
fn fs_main() -> @location(0) vec4<f32> {
    return material.color;
}

===== FILE: engine/render/src/renderer/shaders/main.wgsl =====
// ==========================
// Camera (set = 0, binding = 0)
// ==========================
struct Camera {
    view_proj : mat4x4<f32>,
};

@group(0) @binding(0)
var<uniform> camera : Camera;


// ==========================
// Material (set = 1, binding = 0)
// ==========================
struct Material {
    color : vec4<f32>,
};

@group(1) @binding(0)
var<uniform> material : Material;


// ==========================
// Vertex IO
// ==========================
struct VertexInput {
    @location(0) position : vec3<f32>,
};

struct VertexOutput {
    @builtin(position) clip_pos : vec4<f32>,
};


// ==========================
// Vertex Shader
// ==========================
@vertex
fn vs_main(input : VertexInput) -> VertexOutput {
    var out : VertexOutput;
    out.clip_pos = camera.view_proj * vec4<f32>(input.position, 1.0);
    return out;
}


// ==========================
// Fragment Shader
// ==========================
@fragment
fn fs_main() -> @location(0) vec4<f32> {
    return material.color;
}

===== FILE: engine/render/src/renderer/shaders/overlay.wgsl =====
struct VertexIn {
    @location(0) position: vec2<f32>,
    @location(1) color: vec3<f32>,
};

struct VertexOut {
    @builtin(position) position: vec4<f32>,
    @location(0) color: vec3<f32>,
};

@vertex
fn vs_main(v: VertexIn) -> VertexOut {
    var out: VertexOut;
    out.position = vec4<f32>(v.position, 0.0, 1.0);
    out.color = v.color;
    return out;
}

@fragment
fn fs_main(v: VertexOut) -> @location(0) vec4<f32> {
    return vec4<f32>(v.color, 1.0);
}

===== FILE: engine/render/src/renderer/uniforms/camera.rs =====
use glam::{Mat4, Vec3};

#[repr(C)]
#[derive(Copy, Clone, bytemuck::Pod, bytemuck::Zeroable)]
pub struct CameraUniform {
    pub view_proj: [[f32; 4]; 4],
}

pub struct OrbitCamera {
    pub target: Vec3,
    pub distance: f32,

    pub yaw: f32,
    pub pitch: f32,
}

impl OrbitCamera {
    pub fn new() -> Self {
        Self {
            target: Vec3::ZERO,
            distance: 8.0,
            yaw: 0.0,
            pitch: -0.6,
        }
    }

    pub fn handle_mouse(
        &mut self,
        mouse_dx: f32,
        mouse_dy: f32,
        scroll: f32,
        middle_mouse_held: bool,
    ) {
        // zoom
        self.distance -= scroll * 0.5;
        self.distance = self.distance.clamp(2.0, 50.0);

        // rotate only while MMB held
        if middle_mouse_held {
            let sensitivity = 0.005;
            self.yaw += mouse_dx * sensitivity;
            self.pitch += mouse_dy * sensitivity;

            // vertical camera limits
            let min_pitch = -0.9;
            let max_pitch =  0.0;
            self.pitch = self.pitch.clamp(min_pitch, max_pitch);
        }
    }

    pub fn view_matrix(&self) -> Mat4 {
        let dir = Vec3::new(
            self.pitch.cos() * self.yaw.sin(),
            self.pitch.sin(),
            self.pitch.cos() * self.yaw.cos(),
        );

        let pos = self.target - dir * self.distance;
        Mat4::look_at_rh(pos, self.target, Vec3::Y)
    }
}

===== FILE: engine/render/src/renderer/uniforms/material.rs =====
use bytemuck::{Pod, Zeroable};
use wgpu::util::DeviceExt;

#[repr(C)]
#[derive(Copy, Clone, Pod, Zeroable)]
pub struct MaterialUniform {
    pub color: [f32; 4],
}

pub struct Material {
    pub uniform: MaterialUniform,
    pub buffer: wgpu::Buffer,
    pub bind_group: wgpu::BindGroup,
}

impl Material {
    pub fn new(
        device: &wgpu::Device,
        layout: &wgpu::BindGroupLayout,
        color: [f32; 4],
    ) -> Self {
        let uniform = MaterialUniform { color };

        let buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("material_buffer"),
            contents: bytemuck::bytes_of(&uniform),
            usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
        });

        let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
            layout,
            entries: &[wgpu::BindGroupEntry {
                binding: 0,
                resource: buffer.as_entire_binding(),
            }],
            label: Some("material_bind_group"),
        });

        Self {
            uniform,
            buffer,
            bind_group,
        }
    }
}

===== FILE: engine/render/src/renderer/uniforms/mod.rs =====
pub mod camera;
pub mod model;
pub mod player;
pub mod time;
pub mod material;

pub use camera::CameraUniform;
pub use model::ModelUniform;
pub use player::PlayerUniform;
pub use time::TimeUniform;

===== FILE: engine/render/src/renderer/uniforms/model.rs =====
use bytemuck::{Pod, Zeroable};

#[repr(C)]
#[derive(Copy, Clone, Pod, Zeroable)]
pub struct ModelUniform {
    pub model: [[f32; 4]; 4],
    pub is_floor: u32,
    pub _pad: [u32; 3],
}

impl ModelUniform {
    pub fn new(model: [[f32; 4]; 4], is_floor: bool) -> Self {
        Self {
            model,
            is_floor: if is_floor { 1 } else { 0 },
            _pad: [0; 3],
        }
    }
}

===== FILE: engine/render/src/renderer/uniforms/player.rs =====
use bytemuck::{Pod, Zeroable};

#[repr(C)]
#[derive(Copy, Clone, Pod, Zeroable)]
pub struct PlayerUniform {
    pub position: [f32; 3],
    pub speed: f32,
}

impl PlayerUniform {
    pub fn new(position: [f32; 3], speed: f32) -> Self {
        Self { position, speed }
    }
}

===== FILE: engine/render/src/renderer/uniforms/time.rs =====
use bytemuck::{Pod, Zeroable};

#[repr(C)]
#[derive(Copy, Clone, Pod, Zeroable)]
pub struct TimeUniform {
    pub t: f32,
    pub _pad: [f32; 3],
}

impl TimeUniform {
    pub fn new(t: f32) -> Self {
        Self { t, _pad: [0.0; 3] }
    }
}

===== FILE: game/client/cargo.toml =====
[package]
name = "client"
version = "0.1.0"
edition = "2021"

[[bin]]
name = "client"
path = "src/main.rs"

[dependencies]
render = { path = "../../engine/render" }

winit = "0.28"
glam = "0.25"
pollster = "0.3"

===== FILE: game/client/src/main.rs =====
fn main() {
    render::app::run();
}

===== FILE: game/server/cargo.toml =====
[package]
name = "server"
version = "0.1.0"
edition = "2021"

[dependencies]
core = { path = "../../engine/core" }
net = { path = "../../engine/net" }

===== FILE: game/server/src/main.rs =====
fn main() {
    println!("Server starting...");
    // Initialize world state, listen for client connections, run game loop.
}

